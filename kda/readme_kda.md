# README: Реализация конечного детерминированного автомата (КДА)

## Описание задачи
Код реализует конечный детерминированный автомат (КДА) для поиска строки в тексте. Используются основные компоненты автомата:
- Множество состояний.
- Алфавит.
- Начальное состояние.
- Множество терминальных состояний.
- Функция перехода, которая управляет изменением состояния автомата.

---

## Основные элементы КДА

1. **Множество состояний**:
   - Все состояния представляют собой целые числа от `0` до длины строки `m`.  
   - Каждое состояние описывает, сколько символов текущей строки было совпадено на данный момент.

2. **Алфавит**:
   - Алфавит определяется символами из входной строки `inText`.  
   - Пример: для строки `abcab` алфавит будет `{a, b, c}`.

3. **Начальное состояние**:
   - Начальное состояние всегда равно `0`. Оно обозначает, что автомат ещё не распознал ни одного символа строки.

4. **Множество терминальных состояний**:
   - Терминальным состоянием является состояние `m` (длина строки `inText`). Когда автомат достигает этого состояния, это значит, что строка полностью совпала с входными данными.

5. **Функция перехода**:
   - Описывается таблицей `del`, которая задаёт, какое состояние будет активным в зависимости от текущего символа и текущего состояния.

---

## Как работает код

### 1. Определение алфавита
```javascript
let alph = new Array();
for(let i = 0; i < m; i++)
    alph[inText.charAt(i)] = 0;
```
- Перебираются символы строки `inText`, и каждый уникальный символ добавляется в алфавит.

### 2. Инициализация таблицы переходов
```javascript
let del = new Array(m + 1);
for(let j = 0; j <= m; j++)
    del[j] = new Array();
for(i in alph)
    del[0][i] = 0;
```
- Создаётся двумерный массив `del`, где каждая строка соответствует состоянию, а каждый столбец — символу алфавита.
- Все переходы из начального состояния (`0`) инициализируются в состояние `0`.

### 3. Формирование функции перехода
```javascript
for(let j = 0; j < m; j++){
    prev = del[j][inText.charAt(j)];
    del[j][inText.charAt(j)] = j + 1; 
    for(i in alph)
        del[j + 1][i] = del[prev][i];
}
```
- Для каждого состояния (`j`) определяется переход на основе текущего символа строки.
- Переходы для других символов алфавита обновляются в соответствии с предыдущим состоянием.

### 4. Вывод таблицы переходов
```javascript
for(j = 0; j <= m; j++){ 
    out = '';
    for(i in alph)
        out += del[j][i] + ' ';
    console.log(out);
}
```
- Таблица переходов выводится в формате:  
  ```
  0 0 1
  0 2 0
  3 0 0
  ...
  ```

### 5. Поиск строки
```javascript
let results = new Array();
let state = 0;
for(let i = 0; i < inText.length; i++){
    if(inText.charAt(i) in alph)
        state = del[state][inText.charAt(i)];
    else
        state = 0;
    if(state == m)
        results.push(i - m);
}
console.log(results);
```
- Автомат считывает символы строки и вычисляет новое состояние с помощью функции перехода.
- Если достигается терминальное состояние (`m`), фиксируется индекс, где обнаружено совпадение.

---

## Пример работы

### Входные данные:
Файл `input.txt` содержит строку:  
```
abcab
```

### Таблица переходов:
Для строки `abcab`, алфавит: `{a, b, c}`. Таблица переходов будет выглядеть так:
```
0 0 1
0 2 0
3 0 0
0 4 0
5 0 0
```

### Логика переходов:
- Состояние `0`: При `a` → `1`.  
- Состояние `1`: При `b` → `2`.  
- Состояние `2`: При `c` → `3`.  
- Состояние `3`: При `a` → `4`.  
- Состояние `4`: При `b` → `5` (терминальное).

### Вывод результата:
Если входной текст:  
```
abcabcab
```
Результат:
```
[0, 3]
```
Это означает, что строка найдена дважды: начиная с индексов `0` и `3`.

---

## Использование
1. Создайте текстовый файл `input.txt` с текстом, который нужно обработать.
2. Запустите скрипт, указав файл как аргумент:
   ```bash
   node kda.js input.txt
   ```
3. Результаты будут выведены в консоль.

