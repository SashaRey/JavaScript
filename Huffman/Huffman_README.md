
# Реализация алгоритма Хаффмана

Данный код реализует алгоритм Хаффмана для сжатия текста. Алгоритм создаёт префиксное дерево на основе частот символов входной строки, формирует коды для каждого символа и позволяет как кодировать, так и декодировать строки.

---

## Основные компоненты

### 1. **Подсчёт частот символов**
Входная строка анализируется для определения частоты появления каждого символа. Частоты хранятся в объекте `alph`.

### 2. **Структура узла дерева**
Для представления дерева используется объект `Node`, который содержит:
- `name` — название узла (символ или их комбинация),
- `freq` — частота узла,
- `used` — флаг, показывающий, был ли узел уже использован,
- `left` и `right` — ссылки на потомков,
- `code` — код узла.

### 3. **Построение дерева Хаффмана**
- На каждом шаге два узла с минимальной частотой объединяются в новый узел.
- Процесс продолжается до тех пор, пока не останется один корневой узел.

``` javascript
while (tree.filter(node => !node.used).length > 1) {
    let min1 = null;
    let min2 = null;

    // Первый проход: находим узел с минимальной частотой
    for (let node of tree) {
        if (!node.used && (min1 === null || node.freq <= min1.freq)) {
            min1 = node;
        }
    }
    min1.used = true; // Помечаем как использованный

    // Второй проход: находим следующий узел с минимальной частотой
    for (let node of tree) {
        if (!node.used && (min2 === null || node.freq <= min2.freq)) {
            min2 = node;
        }
    }
    min2.used = true; // Помечаем как использованный
        // Создаём новый объединённый узел
    let newNode = new Node(min1.name + min2.name, min1.freq + min2.freq, false, undefined, '');
    newNode.left = min1;
    newNode.right = min2;
    tree.push(newNode);
}
```

### 4. **Назначение кодов**
Функция `assignCodes` рекурсивно обходит дерево, назначая коды символам:
- Левому потомку добавляется `0`,
- Правому потомку добавляется `1`.

``` javascript

// Функция для рекурсивного обхода дерева и назначения кодов
function assignCodes(node, currentCode = '') {
    if (node === null) return;

    if (!node.left && !node.right) {
        codes[node.name] = currentCode;
        symbolCodes[currentCode] = node.name; // Сохраняем код символа в словаре
    } else {
        assignCodes(node.left, currentCode + '0');
        assignCodes(node.right, currentCode + '1');
    }
}

```


### 5. **Кодирование строки**
Для кодирования входной строки каждый символ заменяется соответствующим ему кодом из словаря `codes`.

``` javascript

symbolCodes[currentCode] = node.name; // Сохраняем код символа в словаре

```

### 6. **Декодирование строки**
Для декодирования строки используется обратный словарь `symbolCodes`, который преобразует коды обратно в символы.

``` javascript

function decodeString(encodedString) {
    let decodedString = '';
    let currentCode = ''; // Переменная для хранения текущего кода

    for (let char of encodedString) {
        currentCode += char;
        if (currentCode in symbolCodes) {
            decodedString += symbolCodes[currentCode];
            currentCode = ''; // Сбрасываем текущий код
        }
    }

    return decodedString;
}
```

---

## Пример работы

### Входная строка
```
abrakadabra
```

### Этапы выполнения

1. **Подсчёт частот символов**
   ```
   {
     'a': 5,
     'b': 2,
     'r': 2,
     'k': 1,
     'd': 1
   }
   ```

2. **Построение дерева**
   Узлы объединяются на основе минимальной частоты.
   Первый проход:

   Находится минимальный узел min1 среди всех узлов, которые ещё не использованы (!node.used).
   После выбора min1 он помечается как использованный (min1.used = true).

   Второй проход:

   Теперь ищется следующий минимальный узел min2, снова среди всех узлов, которые не использованы.
   Так как min1 был помечен как использованный, он уже не может быть выбран повторно.

3. **Назначение кодов**
   - `a`: `0`
   - `b`: `10`
   - `c`: `110`
   - `d`: `111`

4. **Кодирование строки**
   Закодированная строка:
   ```
   000010101011011011011111
   ```

5. **Декодирование строки**
   Раскодированная строка совпадает с исходной:
   ```
   aaaabbbbccd
   ```

---

## Функции

### 1. `assignCodes(node, currentCode)`
Рекурсивно назначает коды символам, обходя дерево.

### 2. `decodeString(encodedString)`
Принимает закодированную строку и декодирует её, используя словарь `symbolCodes`.

---

## Консольный вывод

1. Закодированная строка:
   ```
   01101110100010101101110
   ```

2. Словарь символов и их кодов:
   ```
   { a: '0', b: '110', r: '111', k: '100', d: '101'}
   ```

3. Декодированная строка:
   ```
   abrakadabra
   ```

---

## Преимущества

- Сжатие данных за счёт использования частотных кодов.
- Устойчивость к ошибкам, так как коды префиксные (никакой код не является началом другого).

