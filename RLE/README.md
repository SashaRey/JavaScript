# RLE-Инструмент (Run-Length Encoding)

Этот скрипт реализует алгоритм Run-Length Encoding (RLE) для сжатия и распаковки текстовых файлов. Он поддерживает кодирование повторяющихся символов в более компактный формат и их декодирование обратно в исходный вид.

## Особенности

- **Кодирование**: Сжимает последовательности повторяющихся символов в более компактный формат с использованием RLE.
- **Декодирование**: Восстанавливает оригинальную строку из её сжатого RLE-формата.
- **Поддержка длинных последовательностей**: Обрабатывает последовательности повторяющихся символов, превышающие 255 вхождений.
- **Вычисление коэффициента сжатия**: Отображает эффективность процесса кодирования.

## Как это работает

### Функция кодирования: `encodeString(s)`

Функция `encodeString` обрабатывает входную строку `s` и сжимает повторяющиеся символы с помощью RLE. Логика работы функции следующая:

1. **Инициализация**: Переменная `code` хранит закодированный результат, а индекс `i` используется для итерации по строке.
   ```javascript
   let code = '';
   let i = 0;
   ```

2. **Подсчёт символов**: Для каждого символа функция считает, сколько раз он повторяется подряд.
   ```javascript
   let currentSymbol = s[i];
   let count = 1;

   while (currentSymbol === s[i + count]) {
       count++;
   }
   ```

3. **Особая обработка символа `#`**: Если символ — это `#`, он кодируется по-другому, чтобы избежать конфликтов с маркером кодирования:
   - Повторяющиеся символы `#` разбиваются на части по 255 вхождений, каждая из которых кодируется как `#\xFF#`.
   ```javascript
   if (currentSymbol === '#') {
       while (count > 255) {
           code += `#\xFF#`;
           count -= 255;
       }
       code += `#${String.fromCharCode(count)}#`;
   }
   ```

4. **Кодирование повторяющихся символов**: Для других символов, повторяющихся 4 и более раз:
   - Они также разбиваются на части, если количество превышает 255.
   - Каждая часть кодируется как `#<count><character>`.
   ```javascript
   else if (count >= 4) {
       while (count > 255) {
           code += `#\xFF${currentSymbol}`;
           count -= 255;
       }
       code += `#${String.fromCharCode(count)}${currentSymbol}`;
   }
   ```

5. **Добавление некодированных символов**: Символы, повторяющиеся менее 4 раз, добавляются напрямую в результат.
   ```javascript
   else {
       code += s.slice(i, i + count);
   }
   ```

6. **Обновление индекса**: Индекс `i` увеличивается на количество обработанных символов.
   ```javascript
   i += count;
   ```

### Функция декодирования: `decodeString(s)`

Функция `decodeString` восстанавливает оригинальную строку из сжатого формата. Шаги декодирования следующие:

1. **Инициализация**: Переменная `decoded` хранит результат декодирования, а индекс `i` используется для итерации по сжатой строке.
   ```javascript
   let decoded = '';
   let i = 0;
   ```

2. **Обработка закодированных блоков**: При обнаружении `#` функция считывает следующие символы, чтобы определить количество повторений и символ для добавления.
   ```javascript
   if (s[i] === '#' && i + 1 < s.length) {
       let count = s.charCodeAt(i + 1);
       let char = s[i + 2];
   ```

3. **Декодирование повторяющихся `#`**: Если символ — это `#`, он добавляется в результат несколько раз.
   ```javascript
       if (char === '#') {
           decoded += '#'.repeat(count);
           i += 3;
       }
   ```

4. **Декодирование других символов**: Для других символов они повторяются `count` раз и добавляются в результат.
   ```javascript
       else {
           decoded += char.repeat(count);
           i += 3;
       }
   ```

5. **Добавление некодированных символов**: Символы, не начинающиеся с `#`, добавляются напрямую в результат.
   ```javascript
   else {
       decoded += s[i];
       i++;
   }
   ```

### Основная логика скрипта

Скрипт обрабатывает аргументы командной строки для определения режима (`encode` или `decode`) и входного/выходного файлов. В зависимости от режима он:

1. Читает входной файл.
2. Кодирует или декодирует его содержимое.
3. Записывает результат в выходной файл.
4. Отображает коэффициент сжатия в режиме `encode`.

#### Пример

**Входной файл (`input.txt`)**:
```
aaaabbbb#####
```

**Команда**:
```bash
node rle.js encode input.txt encoded.txt
```

**Закодированный файл (`encoded.txt`)**:
```
#\x04a#\x04b#\x05#
```

**Команда**:
```bash
node rle.js decode encoded.txt output.txt
```

**Выходной файл (`output.txt`)**:
```
aaaabbbb#####
```

## Использование

### Синтаксис
```bash
node rle.js <mode> <inputFile> <outputFile>
```
- `<mode>`: `encode` или `decode`.
- `<inputFile>`: Путь к входному файлу.
- `<outputFile>`: Путь к выходному файлу.

### Примеры команд

1. **Кодирование**:
   ```bash
   node rle.js encode input.txt encoded.txt
   ```
2. **Декодирование**:
   ```bash
   node rle.js decode encoded.txt output.txt
   ```

## Обработка ошибок

- Если аргументы отсутствуют, скрипт отображает инструкцию по использованию и завершает работу.
- Неверные режимы (`encode` или `decode`) приводят к сообщению об ошибке.
- Ошибки чтения/записи файлов обрабатываются с использованием стандартных методов Node.js.



