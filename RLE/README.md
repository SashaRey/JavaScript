# Run-Length Encoding (RLE)

Этот скрипт реализует алгоритм Run-Length Encoding (RLE) для эффективного сжатия и восстановления текстовых данных. Он поддерживает операции кодирования и декодирования для текстовых файлов и предоставляет возможность обработки больших блоков повторяющихся символов.

## Возможности

- **Кодирование**: Сжимает повторяющиеся символы в текстовом файле, заменяя их более компактной нотацией.
- **Декодирование**: Восстанавливает исходный текст из сжатого формата.
- **Поддержка символа `#`**: Символы `#` обрабатываются специальным образом для предотвращения конфликтов.
- **Рассчёт коэффициента сжатия**: При кодировании отображается эффективность сжатия.

## Использование

Скрипт работает в двух режимах:

1. `encode` - Кодирует входной текст.
2. `decode` - Декодирует ранее сжатый текст.

### Синтаксис команды

```
node rle.js <mode> <inputFile> <outputFile>
```

- `<mode>`: Режим работы. Либо `encode`, либо `decode`.
- `<inputFile>`: Путь к входному файлу.
- `<outputFile>`: Путь к выходному файлу.

### Примеры команд

1. **Кодирование файла**

   ```bash
   node rle.js encode input.txt encoded.txt
   ```

   Кодирует содержимое файла `input.txt` и сохраняет результат в `encoded.txt`. Также в консоль выводится коэффициент сжатия.

2. **Декодирование файла**

   ```bash
   node rle.js decode encoded.txt decoded.txt
   ```

   Восстанавливает исходное содержимое из файла `encoded.txt` и сохраняет результат в `decoded.txt`.

## Объяснение кода

### Функции

#### `encodeString(s)`

Кодирует строку с использованием RLE.

- **Логика**:
  1. Подсчитывает количество подряд идущих символов.
  2. Если символ встречается 4 или более раз, заменяет его на формат: `#<количество><символ>`.
  3. Если символ - `#`, используется экранирование, чтобы избежать конфликтов: `#<количество>#`.
  4. Если количество превышает 255, разбивает его на несколько частей.

- **Пример**:
  - Входная строка: `aaaabbbb#####`
  - Закодированная строка: `#\u0004a#\u0004b#\u0005#`

#### `decodeString(s)`

Декодирует строку, ранее сжатую с помощью RLE.

- **Логика**:
  1. Распознаёт блоки формата `#<количество><символ>`.
  2. Восстанавливает символы в количестве, указанном в блоке.
  3. Обрабатывает символы `#` в формате `#<количество>#`.

- **Пример**:
  - Входная строка: `#\u0004a#\u0004b#\u0005#`
  - Декодированная строка: `aaaabbbb#####`

### Основной поток выполнения

1. Парсинг аргументов командной строки:
   - `mode` определяет операцию (`encode` или `decode`).
   - `inputFile` и `outputFile` указывают пути к файлам.

2. В зависимости от режима:
   - Читает содержимое входного файла.
   - Выполняет кодирование или декодирование.
   - Записывает результат в выходной файл.

3. Дополнительно:
   - При кодировании вычисляется коэффициент сжатия как отношение длины исходного текста к длине сжатого текста.

### Обработка ошибок

- **Отсутствие аргументов**: Выводится инструкция по использованию, выполнение прекращается.
- **Неверный режим**: Выводится сообщение об ошибке, выполнение прекращается.
- **Ошибки чтения/записи файлов**: Обрабатываются стандартными методами Node.js.

## Пример входных и выходных данных

### Входной файл (`input.txt`):

```
abb....b(823 раз)#ccee...e(513 раз)f####
```

### Команда:

```bash
node rle.js encode input.txt encoded.txt
```

### Закодированный файл (`encoded.txt`):

```
a#255b#255b#255b#7b#1#cc#255e#255eeeef#4$
```
Примечание: символы от 0 до 31 являются непечатными в ASCII

### Декодированный файл (`decoded.txt`):

```
aaaabbbb#####
```

## Зависимости

- Node.js (для запуска скрипта).
- Встроенный модуль `fs` для работы с файлами.

## Лицензия

Этот проект распространяется под лицензией MIT.

