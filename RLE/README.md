# Описание программы RLE-кодирования и декодирования

Данная программа реализует алгоритм Run-Length Encoding (RLE) для сжатия и восстановления строк. Она работает с текстовыми файлами, предоставляя два режима: кодирование ("encode") и декодирование ("decode").

## Использование

Для запуска программы необходимо использовать команду:

```bash
node rle.js <mode> <inputFile> <outputFile>
```

### Параметры:
- `<mode>`: Режим работы программы. Возможные значения:
  - `encode`: Кодирование строки из входного файла.
  - `decode`: Декодирование строки из входного файла.
- `<inputFile>`: Путь к входному файлу с исходными данными.
- `<outputFile>`: Путь к выходному файлу для сохранения результата.

## Пример

### Кодирование строки
Входной файл `input.txt` содержит строку:
```
aaaabbb#cccccc
```

Запуск команды:
```bash
node rle.js encode input.txt encoded.txt
```
Результат будет записан в файл `encoded.txt`, например:
```
#\u0004abbb#\u0001##\u0006c
```
Также программа выведет коэффициент сжатия:
```
Compression ratio: 2.25
```

### Декодирование строки
Входной файл `encoded.txt` содержит строку:
```
#\u0004a#\u0003b#\u0001##\u0006c
```

Запуск команды:
```bash
node rle.js decode encoded.txt decoded.txt
```
Результат будет записан в файл `decoded.txt`:
```
aaaabbb#cccccc
```
Программа сообщит об успешной декодировании:
```
Decoded successfully.
```

## Обработка ошибок

1. Если не указаны все параметры, программа выведет сообщение:
   ```
   Usage: node rle.js <mode> <inputFile> <outputFile>
   ```
2. Если указан некорректный режим, будет выведено:
   ```
   Invalid mode. Use 'encode' or 'decode'.
   ```

## Код программы

### Основные функции

### Функция кодирования
Функция `encodeString(s)` выполняет следующие действия:

1. **Подсчёт повторяющихся символов**
   - Проходя по строке, функция определяет, сколько раз подряд повторяется текущий символ.

2. **Кодирование длинных последовательностей**
   - Если символ повторяется более 255 раз, последовательность разбивается на блоки по 255 символов.
   - Каждый блок кодируется в формате `#<число><символ>`, где `<число>` — ASCII-код количества повторений.

3. **Обработка символа `#`**
   - Символ `#` кодируется в специальном формате: `#<число>#`.

4. **Добавление коротких последовательностей**
   - Если символ повторяется менее 4 раз (и это не `#`), он добавляется в закодированную строку без изменений.

```javascript
function encodeString(s) {
    let code = "";
    let count = 1;

    for (let i = 0; i < s.length; i++) {
        if (s[i] === s[i + 1]) {
            count++;
        } else {
            
            while (count > 255) {
                code += `#${String.fromCharCode(255)}${s[i]}`;
                count -= 255;
            }

            
            if (count >= 4 || s[i] === '#') {
                code += `#${String.fromCharCode(count)}${s[i]}`;
            } else {
                code += s[i].repeat(count);
            }

            count = 1; 
        }
    }

    return code;
}
```

### Функция декодирования
Функция `decodeString(s)` восстанавливает исходную строку:

1. **Распознавание управляющих последовательностей**
   - Читает последовательности вида `#<число><символ>` и восстанавливает исходные символы.

2. **Обработка символа `#`**
   - Если символ `#` закодирован, он повторяется заданное количество раз.

3. **Добавление некодированных символов**
   - Символы, не входящие в управляющие последовательности, добавляются в результат напрямую.

Пример работы:
- Закодированная строка: `#\u0004a#\u0003b#\u0001##\u0006c`
- Декодированная строка: `aaaabbb#cccccc`

```javascript
function decodeString(s) {
    let decoded = '';
    let i = 0;

    while (i < s.length) {
        if (s[i] === '#' && i + 1 < s.length) {
            let count = s.charCodeAt(i + 1);
            let char = s[i + 2];

            if (char === '#') {
                decoded += '#'.repeat(count);
                i += 3;
            } else {
                decoded += char.repeat(count);
                i += 3;
            }
        } else {
            decoded += s[i];
            i++;
        }
    }

    return decoded;
}
```

