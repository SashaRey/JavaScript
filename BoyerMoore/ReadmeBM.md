
# Boyer-Moore Search Algorithm

Этот репозиторий содержит реализацию алгоритма поиска подстроки **Boyer-Moore**, одного из наиболее эффективных алгоритмов для текстового поиска. Алгоритм использует комбинацию двух правил: **плохого символа** и **хорошего суффикса** для быстрого поиска подстроки в тексте.

## Описание

Алгоритм Boyer-Moore позволяет находить все вхождения заданной подстроки (`pattern`) в строке (`text`). Он работает эффективно за счёт пропуска ненужных сравнений, используя таблицы предвычисленных сдвигов.

## Как работает алгоритм?

1. **Таблица плохих символов**: Если символ в тексте не совпадает с символом в шаблоне, алгоритм использует таблицу плохих символов для определения сдвига шаблона.

2. **Таблица хороших суффиксов**: Если часть шаблона совпадает с текстом, но полное совпадение не найдено, правило хорошего суффикса определяет сдвиг шаблона.

3. Алгоритм сравнивает символы справа налево, начиная с конца шаблона.

---

### Препроцессинг

Ключевыми частями алгоритма являются функции для обработки **правила хорошего суффикса**:

#### 1. `preprocessStrongSuffix`
Эта функция вычисляет таблицу сдвигов для совпадающих суффиксов в шаблоне.

- **Пример работы**:
  Рассмотрим шаблон `pattern = "abcdabc"`. 
  - Если текущий суффикс совпадает с префиксом, например, `abc`, функция запишет смещения для дальнейшего использования.
  - При несовпадении функция передвигается к следующему суффиксу, сохраняя соответствующие значения в массиве `shift`.

- **Основные шаги**:
  1. Итерация начинается с конца шаблона.
  2. Проверяется совпадение суффикса с префиксами.
  3. Если совпадение найдено, записывается сдвиг.
  4. В конце таблица `shift` отображает оптимальные сдвиги для всех суффиксов.

- **Код**:
  ```javascript
  function preprocessStrongSuffix(shift, suffixPos, pattern, m) {
      let i = m; 
      let j = m + 1; 
      suffixPos[i] = j;

      while (i > 0) { 
          while (j <= m && pattern[i - 1] !== pattern[j - 1]) {
              if (shift[j] === 0) {
                  shift[j] = j - i;
              }
              j = suffixPos[j];  
          }
          i--;
          j--;
          suffixPos[i] = j;  
      }
  }
  ```

#### 2. `preprocessCase2`
Эта функция обрабатывает случай, когда текущий суффикс не совпадает ни с одним из префиксов шаблона.

- **Пример работы**:
  Для шаблона `pattern = "abcdabc"`:
  - Если для текущего символа нет совпадений, функция определяет наибольший суффикс, который может быть использован.

- **Основные шаги**:
  1. Инициализация начинается с самого длинного суффикса.
  2. Заполняются значения для символов, у которых нет совпадений.
  3. Если найдено совпадение, обновляется смещение для соответствующих символов.

- **Код**:
  ```javascript
  function preprocessCase2(shift, suffixPos, m) {
      let j = suffixPos[0];
      for (let i = 0; i <= m; i++) {
          if (shift[i] === 0) {
              shift[i] = j;
          }
          if (i === j) {
              j = suffixPos[j];
          }
      }
  }
  ```

---

### Пример

Рассмотрим пример работы алгоритма:

**Текст**: `abcabcabbccabcdabcdabc`  
**Шаблон**: `abcdabc`  

1. Построим таблицы:
   - **Таблица плохих символов**:
     ```
     {
       'a': 1,
       'b': 2,
       'c': 3,
       'd': 4
     }
     ```
   - **Таблица хороших суффиксов**:
     ```
     Index | Shift
     0     | 7
     1     | 6
     2     | 5
     3     | 4
     4     | 3
     5     | 2
     6     | 1
     7     | 7
     ```

2. Сравнение шаблона с текстом:
   - Начинаем с конца шаблона.
   - При несовпадении используем таблицы для определения сдвига.

3. Результат: Позиции совпадений в тексте: `[10, 17]`.

---

### Установка и запуск

1. Склонируйте репозиторий:
   ```bash
   git clone https://github.com/username/boyer-moore.git
   cd boyer-moore
   ```

2. Запустите скрипт:
   ```bash
   node boyerMoore.js
   ```

---

### Вывод

```
Таблица плохих символов: { a: 1, b: 2, c: 3, d: 4 }
Index | Shift
0     | 7
1     | 6
2     | 5
3     | 4
4     | 3
5     | 2
6     | 1
7     | 7
Позиции совпадений: [10, 17]
```

---

### Лицензия

Этот проект лицензирован под MIT License.
