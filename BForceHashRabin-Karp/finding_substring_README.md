# Поиск подстроки в тексте: три алгоритма

Этот проект содержит три реализации алгоритмов поиска подстроки в тексте. Они демонстрируют различные подходы к поиску шаблона в тексте, включая прямой перебор, алгоритм с простой хэш-функцией и алгоритм Рабина-Карпа. В качестве примера используется текст из файла `warandpeace.txt`, а искомая подстрока — "князь Андрей".

## Алгоритм 1: Прямой перебор

### Описание
Прямой перебор (bruteforce) — это самый простой способ поиска. Он последовательно проверяет каждое окно текста, сравнивая символы шаблона с символами текущего окна.

### Как работает
1. Берётся окно текста той же длины, что и шаблон.
2. Каждый символ окна сравнивается с соответствующим символом шаблона.
3. Если символы совпадают, фиксируется индекс начала окна.
4. Окно сдвигается на один символ вправо, и процесс повторяется.

### Недостатки
- Низкая эффективность на больших текстах.
- Количество операций сравнения пропорционально произведению длины текста и шаблона.


Основная функция:

``` javascript

function bruteforceSearch(text, pattern) {
    const indices = [];
    const start = performance.now();

    const textLength = text.length;
    const patternLength = pattern.length;

    for (let i = 0; i <= textLength - patternLength; i++) {
        let found = true;
        for (let j = 0; j < patternLength; j++) {
            if (text[i + j] !== pattern[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            indices.push(i);
        }
    }

    const end = performance.now();
    const elapsed = end - start;

    return {
        indices,
        timeInMilliseconds: elapsed
    };
}
```

---

## Алгоритм 2: Поиск с простой хэш-функцией

### Описание
В этом алгоритме для ускорения поиска используется простая хэш-функция — сумма ASCII-кодов символов строки. Сравнение строк производится только в случае совпадения хэшей.

### Как работает
1. Вычисляется хэш шаблона (сумма ASCII-кодов всех его символов).
2. Хэш вычисляется для первого окна текста той же длины, что и шаблон.
3. Если хэши совпадают, выполняется побуквенное сравнение окна с шаблоном.
4. Окно сдвигается, а хэш пересчитывается с использованием рекуррентной формулы:
   
   \[
   H_{\text{new}} = H_{\text{old}} - \text{ASCII} (\text{левый\ символ}) + \text{ASCII} (\text{новый\ символ})
   \]

### Основная функция

``` javascript 

function HashSum(string, pattern) {
    // Статистика: время выполнения, совпадения, коллизии, количество сравнений
    const result = {
        executionTime: 0,       // Время выполнения поиска
        matches: [],            // Массив индексов начала всех совпадений
        exactMatches: 0,        // Количество точных совпадений
        collisions: 0,          // Количество коллизий хэшей
        characterComparisons: 0 // Количество сравнений символов
    };

    const patternLength = pattern.length; // Длина подстроки
    const stringLength = string.length;   // Длина строки
    let patternHash = 0;  // Хэш подстроки
    let currentHash = 0;  // Хэш текущего окна в строке

    // Вычисляем хэш подстроки и хэш первого окна в строке
    for (let i = 0; i < patternLength; i++) {
        patternHash += pattern.charCodeAt(i);   // Суммируем ASCII-коды символов подстроки
        currentHash += string.charCodeAt(i);    // Суммируем ASCII-коды символов первого окна строки
    }

    const startTime = performance.now();  // Запоминаем время начала выполнения поиска

    // Основной цикл: сдвигаем окно по строке и сравниваем хэши
    for (let left = 0, right = patternLength; right <= stringLength; left++, right++) {
        // Проверяем, совпадают ли хэши текущей подстроки и шаблона
        if (currentHash === patternHash) {
            // Если хэши совпали, проверяем совпадение подстроки и фрагмента строки
            if (compareChars(string, left, pattern, result)) {
                result.matches.push(left);  // Записываем индекс начала совпадения
                result.exactMatches++;      // Увеличиваем счетчик точных совпадений
            } else {
                result.collisions++;  // Если строки не совпали, увеличиваем счетчик коллизий
            }
        }

        // Обновляем хэш текущей подстроки:
        // убираем старый символ (на позиции left) и добавляем новый (на позиции right)
        if (right < stringLength) {
            currentHash = currentHash - string.charCodeAt(left) + string.charCodeAt(right);
        }
    }

    result.executionTime = performance.now() - startTime;  // Вычисляем время выполнения поиска

    return result;  // Возвращаем объект с результатами поиска
}
```

### Преимущества
- Рекуррентная формула позволяет пересчитывать хэш за константное время, не проходя по каждому символу окна.

### Недостатки
- Возможны коллизии, когда разные строки дают одинаковый хэш.
- Требуется дополнительное побуквенное сравнение для исключения ложных совпадений.



---

## Алгоритм 3: Рабин-Карп

### Описание
Алгоритм Рабина-Карпа использует более сложную хэш-функцию для уменьшения числа коллизий. Хэш для строки вычисляется как сумма произведений ASCII-кодов символов на степени основания (обычно 2):

\[
H = \sum_{i=0}^{m-1} \text{ASCII}(\text{символ}_i) \cdot 2^{m-i-1}
\]

### Как работает
1. Вычисляется хэш шаблона и первого окна текста.
2. Если хэши совпадают, выполняется побуквенное сравнение окна с шаблоном.
3. Окно сдвигается, а хэш пересчитывается рекуррентно:

\[
H_{\text{new}} = 2 \cdot (H_{\text{old}} - \text{ASCII}(\text{левый\ символ}) \cdot 2^{m-1}) + \text{ASCII}(\text{новый\ символ})
\]

### Основная функция
``` javascript
function rabinKarpSearch(text, pattern) {
    const stats = {
        executionTime: 0,      // Время выполнения поиска
        matches: [],           // Индексы всех совпадений
        exactMatches: 0,       // Количество точных совпадений
        collisions: 0,         // Количество коллизий
        characterComparisons: 0 // Количество сравнений символов
    };

    const patternLength = pattern.length;
    const textLength = text.length;
    const maxPowerOfTwo = Math.pow(2, patternLength - 1);

    let patternHash = 0; // Хэш шаблона
    let currentHash = 0; // Хэш текущего окна текста

    // Вычисляем хэши шаблона и первого окна текста
    for (let i = 0; i < patternLength; i++) {
        patternHash += pattern.charCodeAt(i) * Math.pow(2, patternLength - i - 1);
        currentHash += text.charCodeAt(i) * Math.pow(2, patternLength - i - 1);
    }

    const startTime = performance.now();

    // Основной цикл
    for (let left = 0, right = patternLength; right <= textLength; left++, right++) {
        // Сравниваем хэши
        if (currentHash === patternHash) {
            // Посимвольная проверка
            let match = true;
            for (let i = 0; i < patternLength; i++) {
                stats.characterComparisons++;
                if (text[left + i] !== pattern[i]) {
                    match = false;
                    stats.collisions++;
                    break;
                }
            }
            if (match) {
                stats.matches.push(left);
                stats.exactMatches++;
            }
        }

        // Обновляем хэш
        if (right < textLength) {
            currentHash = 2 * (currentHash - text.charCodeAt(left) * maxPowerOfTwo) + text.charCodeAt(right);
        }
    }

    stats.executionTime = performance.now() - startTime;
    return stats;
}
```

### Преимущества
- Более низкое число коллизий по сравнению с простой суммой ASCII-кодов.
- Более высокая скорость по сравнению с прямым перебором.

### Недостатки
- Дополнительные вычисления за счёт умножения на 2 в степени.

---

## Что такое хэш-функция и почему она рекуррентная
**Хэш-функция** — это функция, которая преобразует строку произвольной длины в числовое значение фиксированного размера (хэш). В данном случае хэш используется для быстрого сравнения строк.

Хэш-функция является **рекуррентной**, потому что новое значение хэша вычисляется на основе предыдущего хэша, исключая один символ и добавляя другой. Это позволяет пересчитывать хэши без полного повторного прохода по каждому символу строки, что значительно ускоряет работу алгоритма.

---

## Пример запуска
Все три алгоритма используют текст из файла `warandpeace.txt`. Чтобы запустить любой из них, выполните соответствующий код в среде Node.js. Убедитесь, что файл `warandpeace.txt` находится в той же папке.

Пример команды для запуска:
```bash
node bruteforce.js  # Запуск алгоритма прямого перебора
node hash.js        # Запуск алгоритма с простой хэш-функцией
node rabin-karp.js  # Запуск алгоритма Рабина-Карпа
```

### Ожидаемые результаты
- Индексы всех вхождений подстроки в тексте.
- Статистика выполнения: время, количество совпадений, число сравнений символов, число коллизий.

---

## Сравнение алгоритмов
| Алгоритм            | Время выполнения | Устойчивость к коллизиям | Эффективность сравнения |
|---------------------|------------------|--------------------------|-------------------------|
| Прямой перебор      | Долгое           | Не применимо             | Низкая                  |
| Простая хэш-функция | Среднее          | Низкая                   | Средняя                 |
| Рабин-Карп          | Высокое          | Высокая                  | Высокая                 |

---

## Вывод
- Алгоритм прямого перебора прост, но неэффективен для больших текстов.
- Хэш-функции ускоряют поиск, но могут давать коллизии.
- Алгоритм Рабина-Карпа показывает лучшие результаты благодаря более сложной хэш-функции и рекуррентным вычислениям.

Используйте алгоритм в зависимости от требований к скорости и точности поиска.

